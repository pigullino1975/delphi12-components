unit dxAutoGenerateData;

interface

uses
  System.SysUtils, System.Classes, Forms, Data.DB, dxmdaset, DateUtils, Generics.Collections,
  cxEdit, cxEditRepositoryItems, cxClasses, Vcl.ImgList,
  Vcl.Controls, cxImageList, cxGraphics, cxExtEditRepositoryItems, cxStyles, dxCore;

type
  TdxTask = class
  private
    ID: Integer;
    ParentID: Integer;
    Name: string;
    EmployeeName: string;
    Description: string;
    StartDate: TDateTime;
    DueDate: TDateTime;
    Status: 0..100;
    Priority: -1..1;
  end;

  TdmAutoGenerateData = class(TDataModule)
    mdEmployees: TdxMemData;
    mdEmployeesFullName: TStringField;
    mdTasks: TdxMemData;
    mdTasksTaskName: TStringField;
    mdSubtasks: TdxMemData;
    mdSubtasksSubTaskName: TStringField;
    mdSubtasksDescription: TWideStringField;
    mdAutoGenerateTasks: TdxMemData;
    mdAutoGenerateTasksFullEmployeeName: TStringField;
    mdAutoGenerateTasksTaskId: TIntegerField;
    mdAutoGenerateTasksParentTaskId: TIntegerField;
    mdAutoGenerateTasksStartDate: TDateField;
    mdAutoGenerateTasksDueDate: TDateField;
    mdAutoGenerateTasksStatus: TWordField;
    mdAutoGenerateTasksTaskName: TWideStringField;
    mdAutoGenerateTasksDescription: TWideStringField;
    mdAutoGenerateTasksPriority: TShortintField;
    cxEditRepository1: TcxEditRepository;
    cxEditRepository1imcbPriority: TcxEditRepositoryImageComboBoxItem;
    cxImageList1: TcxImageList;
    cxEditRepository1imcbDescriptionVisibility: TcxEditRepositoryImageComboBoxItem;
    cxEditRepository1imcbCompleted: TcxEditRepositoryImageComboBoxItem;
    cxEditRepository1ProgressBar1: TcxEditRepositoryProgressBar;
    cxStyleRepository1: TcxStyleRepository;
    cxStyle1: TcxStyle;
    cxStyle2: TcxStyle;
    DataSource1: TDataSource;
    procedure DataModuleCreate(Sender: TObject);
  private
    FEmployeeIndex: Integer;
    FSubtaskIndex: Integer;
    FTasks: TObjectList<TdxTask>;
    FEmployees: TStringList;
    FTaskNames: TStringList;
    FSubtaskNames: TStringList;
    FSubtaskDescriptions: TStringList;
    procedure CalcDate(ATask: TdxTask; AStartDate, ADueDate: TDateTime);
    function CalcStatus(ATask: TdxTask): Integer;
    function CalcSubtaskCount(ARemainSubtaskCount, ARootCount: Integer): Integer;
    function ChooseEmployeeName: string;
    function GetNextSubtaskIndex: Integer;
    function CanShowDescription: Boolean;
    function ChoosePriority: Integer;
    function GenerateSubtasks(AParentTask: TdxTask; ACount: Integer; var AComplete: Integer): TList<TdxTask>;
  public
    procedure GenerateSource(ACount: Integer);
  end;

var
  dmAutoGenerateData: TdmAutoGenerateData;

implementation

uses
  Math;

{%CLASSGROUP 'Vcl.Controls.TControl'}

{$R *.dfm}

procedure TdmAutoGenerateData.CalcDate(ATask: TdxTask; AStartDate, ADueDate: TDateTime);
var
  ADelta, AMaxStartDelta, AStartDelta: Integer;
  AAllInterval: Integer;
begin
  AAllInterval := DaysBetween(ADueDate, AStartDate);
  ADelta := Random(AAllInterval + 1);
  AMaxStartDelta := AAllInterval - ADelta;
  AStartDelta := Random(AMaxStartDelta + 1);

  ATask.StartDate := IncDay(AStartDate, AStartDelta);
  ATask.DueDate := IncDay(ATask.StartDate, ADelta);
end;

function TdmAutoGenerateData.CalcStatus(ATask: TdxTask): Integer;
begin
  if ATask.StartDate > Date then
    Result := Random(201) div 9
  else
  begin
    Result := RandomRange(800, 1001) div 9;
    if ATask.DueDate > Date then
      Result := Round(Result * DaysBetween(ATask.DueDate, Date) / DaysBetween(ATask.DueDate, ATask.StartDate));
  end;
  Result := Min(Result, 100);
end;

function TdmAutoGenerateData.CalcSubtaskCount(ARemainSubtaskCount,
  ARootCount: Integer): Integer;
var
  AValue: Integer;
begin
  if (ARootCount = 1) or (ARemainSubtaskCount = 0) then
    Result := ARemainSubtaskCount
  else
  begin
    AValue := ARemainSubtaskCount div ARootCount;
    if AValue = 0 then
      Result := 1
    else
      Result := RandomRange(1, AValue + 1);
  end;
end;

function TdmAutoGenerateData.CanShowDescription: Boolean;
begin
  Result := Random(1001) < 600;
end;

procedure TdmAutoGenerateData.DataModuleCreate(Sender: TObject);
var
  APath: string;
begin
  APath := ExtractFilePath(Application.ExeName) + '..\Common\';
  mdEmployees.LoadFromBinaryFile(APath + 'EmployeesForAutoGenerate.dat');
  mdTasks.LoadFromBinaryFile(APath + 'TasksForAutoGenerate.dat');
  mdSubtasks.LoadFromBinaryFile(APath + 'SubtasksForAutoGenerate.dat');

  FEmployees := TStringList.Create;
  mdEmployees.First;
  while not mdEmployees.Eof do
  begin
    FEmployees.Add(dxAnsiStringToString(mdEmployeesFullName.Value));
    mdEmployees.Next;
  end;

  FTaskNames := TStringList.Create;
  mdTasks.First;
  while not mdTasks.Eof do
  begin
    FTaskNames.Add(dxAnsiStringToString(mdTasksTaskName.Value));
    mdTasks.Next;
  end;

  FSubtaskNames := TStringList.Create;
  FSubtaskDescriptions := TStringList.Create;
  mdSubtasks.First;
  while not mdSubtasks.Eof do
  begin
    FSubtaskNames.Add(dxAnsiStringToString(mdSubtasksSubTaskName.Value));
    FSubtaskDescriptions.Add(mdSubtasksDescription.Value);
    mdSubtasks.Next;
  end;

  FTasks := TObjectList<TdxTask>.Create;
  try
    GenerateSource(200);
  finally
    FreeAndNil(FTasks);
  end;

  FreeAndNil(FEmployees);
  FreeAndNil(FTaskNames);
  FreeAndNil(FSubtaskNames);
  FreeAndNil(FSubtaskDescriptions);
end;

procedure TdmAutoGenerateData.GenerateSource(ACount: Integer);
var
  ATask: TdxTask;
  AStartDate, ADueDate: TDateTime;
  ARootTaskCount, ASubtaskCount: Integer;
  I: Integer;
  AId, AParentId: Integer;
  AComplete: Integer;
  ASubTasks: TList<TdxTask>;
begin
  Randomize;
  FEmployeeIndex := 0;
  FSubtaskIndex := 0;
  AStartDate := IncDay(Date, -200);
  ADueDate := IncDay(Date, 200);
  ARootTaskCount := Min(FTaskNames.Count, ACount);
  ASubtaskCount := ACount - ARootTaskCount;
  AId := 1;
  AParentId := 0;
  for I := 0 to ARootTaskCount - 1 do
  begin
    ATask := TdxTask.Create;
    FTasks.Add(ATask);
    ATask.ID := AId;
    Inc(AId);
    ATask.ParentID := AParentId;
    ATask.Name := FTaskNames[I];
    ATask.EmployeeName := ChooseEmployeeName;
    CalcDate(ATask, AStartDate, ADueDate);
    ATask.Priority := ChoosePriority;
    AComplete := 0;
    ASubTasks := GenerateSubtasks(ATask, CalcSubtaskCount(ASubtaskCount, ARootTaskCount - I), AComplete);
    try
      FTasks.AddRange(ASubTasks);
      Inc(AId, ASubTasks.Count);
      Dec(ASubtaskCount, ASubTasks.Count);
      if ASubTasks.Count <> 0 then
        ATask.Status := AComplete div ASubTasks.Count
      else
        ATask.Status := CalcStatus(ATask);
    finally
      ASubtasks.Free;
    end;
  end;

  mdAutoGenerateTasks.Active := True;
  mdAutoGenerateTasks.DisableControls;
  for I := 0 to FTasks.Count - 1 do
  begin
    mdAutoGenerateTasks.Append;
    ATask := FTasks[I];
    mdAutoGenerateTasksTaskId.Value := ATask.ID;
    mdAutoGenerateTasksParentTaskId.Value := ATask.ParentID;
    mdAutoGenerateTasksTaskName.Value := ATask.Name;
    mdAutoGenerateTasksFullEmployeeName.Value := dxStringToAnsiString(ATask.EmployeeName);
    mdAutoGenerateTasksStatus.Value := ATask.Status;
    mdAutoGenerateTasksStartDate.Value := ATask.StartDate;
    mdAutoGenerateTasksDueDate.Value := ATask.DueDate;
    mdAutoGenerateTasksDescription.Value := ATask.Description;
    mdAutoGenerateTasksPriority.Value := ATask.Priority;
  end;
  mdAutoGenerateTasks.Refresh;
  mdAutoGenerateTasks.EnableControls;
end;

function TdmAutoGenerateData.GenerateSubtasks(AParentTask: TdxTask; ACount: Integer; var AComplete: Integer): TList<TdxTask>;
var
  AID: Integer;
  ASubtaskIndex: Integer;
  I: Integer;
  ATask: TdxTask;
begin
  AID := AParentTask.ID + 1;
  Result := TList<TdxTask>.Create;
  for I := 0 to ACount - 1 do
  begin
    ATask := TdxTask.Create;
    Result.Add(ATask);
    ASubtaskIndex := GetNextSubtaskIndex;
    ATask.Name := FSubtaskNames[ASubtaskIndex];
    if CanShowDescription then
      ATask.Description := FSubtaskDescriptions[ASubtaskIndex];
    ATask.EmployeeName := ChooseEmployeeName;
    ATask.ID := AID;
    ATask.ParentID := AParentTask.ID;
    ATask.Priority := ChoosePriority;
    CalcDate(ATask, AParentTask.StartDate, AParentTask.DueDate);
    if I = 0 then
      ATask.StartDate := AParentTask.StartDate;
    if I = ACount - 1 then
      ATask.DueDate := AParentTask.DueDate;
    ATask.Status := CalcStatus(ATask);
    AComplete := AComplete + ATask.Status;
    Inc(AID);
  end;
end;

function TdmAutoGenerateData.GetNextSubtaskIndex: Integer;
begin
  Result := FSubtaskIndex;
  if FSubtaskIndex < FSubtaskNames.Count - 1 then
    Inc(FSubtaskIndex)
  else
    FSubtaskIndex := 0;
end;

function TdmAutoGenerateData.ChooseEmployeeName: string;
begin
  Result := FEmployees[FEmployeeIndex];
  if FEmployeeIndex < FEmployees.Count - 1 then
    Inc(FEmployeeIndex)
  else
    FEmployeeIndex := 0;
end;

function TdmAutoGenerateData.ChoosePriority: Integer;
begin
  Result := RandomRange(-1, 2);
end;

end.
